manifest {

    name = "LMAS - Last Metagenomic Assembler Standing"
    mainScript = "main.nf"
    version = "2.0.1"
    defaultBranch = 'main'

}

env {

    PYTHONPATH = "$baseDir/templates:\$PYTHONPATH"
    PATH = "$baseDir/templates:\$PATH"
}

docker {
    runOptions = "-u \$(id -u):\$(id -g) -v $baseDir:$baseDir" 
}


executor {
    $local {
        cpus = 4
    }
}

singularity {
    cacheDir = "$HOME/.singularity_cache"
    autoMounts = true
    runOptions = "-B $baseDir:$baseDir"
}

trace {
    enabled = true
    file = "pipeline_stats.txt"
    fields = "task_id,\
              hash,\
              process,\
              tag,\
              status,\
              exit,\
              start,\
              container,\
              cpus,\
              time,\
              disk,\
              memory,\
              duration,\
              realtime,\
              queue,\
              %cpu,\
              %mem,\
              rss,\
              vmem,\
              rchar,\
              wchar"
}

params {

    platformHTTP = null
    reportHTTP = null

    /* 
    Execution related defaults
    */
    // process resources defaults
    cpus = 8
    memory = 32.GB
    time = 24.h

    // max resources limits defaults
    max_cpus = 32
    max_memory = 100.GB
    max_time = 72.h
}

process {

    errorStrategy = { task.attempt <= 2 ? "retry" : "ignore" }
    maxRetries = 2
    container = "cimendes/lmas-python-base:0.1"

    cpus = params.cpus
    memory = params.memory

    withLabel:process_assembly {
            cpus = { check_max( params.cpus * task.attempt, 'cpus' ) }
            memory = { check_max( params.memory * task.attempt, 'memory' ) }
            time = { check_max( params.time * task.attempt, 'time' ) }
    }
    withLabel:process_mapping {
            cpus = { check_max( params.cpus * task.attempt, 'cpus' ) }
            memory = { check_max( params.memory * task.attempt, 'memory' ) }
            time = { check_max( params.time * task.attempt, 'time' ) }
    }
    withLabel:process_script {
            cpus = { check_max( 2 * task.attempt, 'cpus' ) }
            memory = { check_max( 8.Gb * task.attempt, 'memory' ) }
            time = { check_max( params.time * task.attempt, 'time' ) }
    }
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
  if (type == 'memory') {
    try {
      if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
        return params.max_memory as nextflow.util.MemoryUnit
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
      return obj
    }
  } else if (type == 'time') {
    try {
      if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
        return params.max_time as nextflow.util.Duration
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
      return obj
    }
  } else if (type == 'cpus') {
    try {
      return Math.min( obj, params.max_cpus as int )
    } catch (all) {
      println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
      return obj
    }
  }
}

includeConfig "conf/profiles.config"
includeConfig "conf/containers.config"
includeConfig "conf/params.config"
